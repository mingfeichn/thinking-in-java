#线程

## 什么是进程？
进程是程序的一次执行过程，是系统运行程序的基本单位
各进程是独立的

## 什么是线程？
线程是一个比进程更小的执行单位，一个进程在执行过程中可以产生多个线程。
同类的多个线程共享一块内存空间和一组资源

## 为什么需要多线程？


## 创建线程的方式有哪些？
1. 继承Thread类

2. 实现Runnable接口

3. 通过Callable和Future创建线程

4. 通过线程池创建线程

### 创建线程的三种方式对比
由于单继承多实现，采用实现Runnable或Callable接口的方式创建多线程时，还可以继承其他类

### 线程池分类
- newFixedThreadPool(int nThreads)
创建固定数目线程的线程池，可控制线程最大并发数，超出的线程会在队列中等待

- newSingleThreadExecutor()
创建一个单线程化的Executor，保证所有的任务按照指定的顺序（FIFO,LIFO,优先级）执行

- newCachedThreadPool()
创建一个可缓存的线程池，调用execute将重用以前构造的线程（如果线程可用），如果现有线程没有可用的则创建一个新线程添加到线程池中。
终止并从缓存中移除那些已有60秒未被使用的线程

- newScheduledThreadPool(int corePoolSize)
创建一个支持定时及周期性的任务执行的线程池，多数情况下可用来代替Timer类

### 使用线程池的好处？
不使用线程池的弊端：
- 每次new Thread新建对象性能差
- 缺乏统一的线程管理，可能无限制新建线程，导致宕机和OOM
- 缺乏更多的功能，如定时执行、线程中断

使用线程池的好处：
- 重用存在的线程，减少对象创建、消亡的开销，性能好
- 可有效控制最大并发线程数，提高系统资源的利用率
- 提供定时执行、单线程、并发数控制

## 线程安全
### 不共享数据


### 共享数据
解决数据不一致问题：synchronized

#### synchronized
- 修饰方法或代码块，保证在同一时刻只有一个线程执行该方法或代码块
- 当两个并发线程访问同一个对象object中的这个synchronized(this)同步代码块时，一个时间内只能有一个线程得到执行。另一个线程必须等待当前线程执行完这个代码块以后才能执行该代码块。
- 然而，当一个线程访问object的一个synchronized(this)同步代码块时，另一个线程仍然可以访问该object中的非synchronized(this)同步代码块。
- 尤其关键的是，当一个线程访问object的一个synchronized(this)同步代码块时，其他线程对object中所有其它synchronized(this)同步代码块的访问将被阻塞。
- 第三个例子同样适用其它同步代码块。也就是说，当一个线程访问object的一个synchronized(this)同步代码块时，它就获得了这个object的对象锁。结果，其它线程对该object对象所有同步代码部分的访问都被暂时阻塞。
- 以上规则对其它对象锁同样适用.

## 中断线程
interrupter

## 线程优先级




